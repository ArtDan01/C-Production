#include <stdio.h>
#include <string.h>

typedef struct list{
    int value; // проле для хранения данных в односвязном спике
    struct list *next; // указатель, нужен чтобы связать элемент( поле) - просто значение в спике со следующим элементом, по-другому нельзя понять что дет дальше, если не завести указатель
} list;

list *head; // указатель на начало списка (на первый элемент)
/*Вначале первого элемента нет и указатель ссылается на NULL
Чтобы добавить УЗЕЛ (value + pointer) нужно:
1. Выделить память
2. Задать значение
3. Сделать так, чтобы он ссылался на предыдущий элемент ( если его не было, то на NULL)
4. Перекинуть указатель *head на новый узел
*/
// Так как указатель head изменяется, то необходимо передавать указатель на указатель.
void push(list **head, int data) { // Указатель на указатель передается для того, чтобы можно было проводить изменения с реальным указателем, а не копией (если передать list *head, то изменения будут видны только внутри функции и реальный спиоск не изменится)
list *tmp = (list*)malloc(sizeof(list));/* Мы создаем элемент, который является указателем на структуру list, далее смотрим на функцию malloc - она возвращает указатель на *void, сама функция выделяяет память в куче(heap) достаточного размера, чтобы поместить структуру list, а (list*) это просто явное приведение типа данных к типу указателя *tmp*/
tmp->value = data; // Присваиваем узлу значение
tmp->next = (*head); // Присваиваем указателю tmp адрес предыдущего узла
(*head) = tmp; // Присваиваем указателю head адрес нового узла
}

void pop(list **head){
    list *prev = NULL; // Если мы перекинем указатель head на следующий элемент, то мы потеряем адрес первого и не сможем его удалить и тем более вернуть его значения. Для этого необходимо сначала создать локальную переменную, которая будет хранить адрес первого элемента
    int val;
    if (head == NULL) { // Проверка на NULL или будет segmentation fault/ необъяснимое поведение из-за отсутствия первого элемента
        exit(-1);
    }
    prev = (*head); // Теперь указатель prev указывает на голову списка и мы можем очистить элемент с указателем head
    val = prev->value;
    (*head) = (*head)->next;
    free(prev);
    return val;
}

int main(){
int data;
printf("Введите данные в int");
scanf("%d", data);
return 0;
}